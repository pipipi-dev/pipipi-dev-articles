---
title: "App Router Directory Design: Next.js Project Structure Patterns"
emoji: "ğŸ¨"
type: "tech"
topics: ["nextjs", "AppRouter", "typescript", "architecture"]
published: false
platforms:
  qiita: false
  zenn: false
  devto: true
---


This is Day 10 of **[Building SaaS Solo - Design, Implementation, and Operation Advent Calendar 2025](https://adventar.org/calendars/12615)**.

Yesterday I wrote about "Why I Migrated to Better Auth." Today I'll explain App Router directory design with actual project structure examples.

## ğŸ“ Terminology Used in This Article

- **CSR (Client Side Rendering)**: A method where HTML is generated by executing JavaScript in the browser
- **SSR (Server Side Rendering)**: A method where HTML is generated on the server before sending to the browser. Results in faster display
- **Streaming**: A method of sending HTML in chunks sequentially. Display begins without waiting for the entire page to load

## ğŸ“– App Router Basics

In App Router, introduced in Next.js 13+, the `app/` directory structure directly maps to URLs.

```
app/
â”œâ”€â”€ page.tsx          â†’ /
â”œâ”€â”€ about/
â”‚   â””â”€â”€ page.tsx      â†’ /about
â””â”€â”€ contents/
    â””â”€â”€ [id]/
        â””â”€â”€ page.tsx  â†’ /contents/123
```

Directories with `page.tsx` are recognized as pages, and dynamic segments like `[id]` can be used. Since you can understand URLs by looking at the directory structure, development is intuitive.

## ğŸ¯ Key Design Considerations

When designing a project with App Router, I focused on these points:

- **Separation of concerns**: Separate by role like app/, client/, server/
- **Layout sharing**: Organize by screen type like auth pages, main app
- **Maintaining SSR**: Keep layouts as Server Components

## ğŸ“ Overall Directory Structure

```
src/
â”œâ”€â”€ app/              # Routing definitions only
â”‚   â”œâ”€â”€ [locale]/     # Internationalization
â”‚   â”‚   â”œâ”€â”€ (auth)/   # Auth pages
â”‚   â”‚   â”œâ”€â”€ (main)/   # Main app
â”‚   â”‚   â””â”€â”€ (marketing)/ # Marketing pages
â”‚   â””â”€â”€ api/          # API endpoints
â”œâ”€â”€ client/           # Client-side code
â”‚   â”œâ”€â”€ components/   # React components
â”‚   â”œâ”€â”€ contexts/     # React Context
â”‚   â”œâ”€â”€ hooks/        # Custom hooks
â”‚   â”œâ”€â”€ lib/          # Client-only utilities
â”‚   â”œâ”€â”€ providers/    # Provider components
â”‚   â””â”€â”€ stores/       # Zustand Store
â”œâ”€â”€ server/           # Server-side code
â”‚   â”œâ”€â”€ actions/      # Server Actions
â”‚   â”œâ”€â”€ api/          # Hono API handlers
â”‚   â”œâ”€â”€ interfaces/   # External service integration
â”‚   â”œâ”€â”€ lib/          # Server-only utilities
â”‚   â”œâ”€â”€ loaders/      # Server-side data fetching
â”‚   â”œâ”€â”€ repositories/ # Data access layer
â”‚   â””â”€â”€ usecases/     # Business logic
â”œâ”€â”€ database/         # Drizzle ORM schemas
â”‚   â”œâ”€â”€ app_admin/    # Admin features
â”‚   â”œâ”€â”€ app_ai/       # AI features
â”‚   â”œâ”€â”€ app_auth/     # Authentication
â”‚   â”œâ”€â”€ app_billing/  # Billing
â”‚   â”œâ”€â”€ app_content/  # Content management
â”‚   â”œâ”€â”€ app_social/   # Social features
â”‚   â””â”€â”€ app_system/   # System logs
â”œâ”€â”€ shared/           # Client/Server shared
â”‚   â”œâ”€â”€ lib/          # Shared utilities
â”‚   â””â”€â”€ types/        # Common type definitions
â”œâ”€â”€ i18n/             # Internationalization config
â””â”€â”€ messages/         # Translation files (ja.json, en.json)
```

### Separation by Role

With App Router, you can put all code in the `app/` directory. However, as the project grows, it becomes harder to manage.

So I separated directories by role. This structure is inspired by the following article:

https://note.com/jujunjun110/n/na653d4120d7e

The clear separation between `client/` and `server/` was particularly effective. In Next.js, accidentally calling server-only modules from the client causes runtime errors, but separating at the directory level helps prevent such mistakes.

- **app/**: Routing definitions only. No business logic
- **client/**: Components and hooks requiring `"use client"`
- **server/**: Server-side only code
- **database/**: DB schema definitions (Drizzle ORM)
- **shared/**: Pure functions and type definitions usable by both
- **i18n/**, **messages/**: Internationalization

This separation makes it clear "where this code belongs."

### Directory Structure Matching DB Schema

The `database/` directory matches the PostgreSQL schema structure.

```
database/
â”œâ”€â”€ app_admin/        # Admin (tenants, teams, members)
â”œâ”€â”€ app_ai/           # AI features (embeddings, search_vectors)
â”œâ”€â”€ app_auth/         # Auth (users, sessions, accounts)
â”œâ”€â”€ app_billing/      # Billing (subscriptions, payment_history)
â”œâ”€â”€ app_content/      # Content management (contents, pages, tables)
â”œâ”€â”€ app_social/       # Social (bookmarks, comments, reactions)
â””â”€â”€ app_system/       # System (activity_logs, system_logs)
```

Each directory corresponds to a PostgreSQL schema. When looking for a table, thinking "which schema does it belong to?" tells you where the file is.

Since `server/repositories/` also follows this schema structure, the flow from DB schema â†’ repository â†’ use case is easy to follow.

## ğŸ—‚ï¸ Using Route Groups

Route Groups let you organize directories without affecting URLs.

```
app/[locale]/
â”œâ”€â”€ (auth)/           # Auth flow layout
â”‚   â”œâ”€â”€ login/
â”‚   â”œâ”€â”€ register/
â”‚   â””â”€â”€ layout.tsx    # Auth page layout
â”œâ”€â”€ (main)/           # Main app layout
â”‚   â”œâ”€â”€ contents/
â”‚   â”œâ”€â”€ settings/
â”‚   â””â”€â”€ layout.tsx    # Layout with sidebar
â””â”€â”€ (marketing)/      # Marketing pages
    â”œâ”€â”€ landing/
    â””â”€â”€ about/
```

By placing `layout.tsx` in each Route Group, you can apply different layouts. Auth pages get a simple layout, main app gets a layout with sidebar.

URLs stay simple like `/login`, `/contents`, while layouts are separated.

## ğŸŒ API Routing Design

API endpoints are separated by role.

```
app/api/
â”œâ”€â”€ [[...route]]/     # Proxy to Hono API
â”œâ”€â”€ auth/             # Better Auth
â”‚   â””â”€â”€ [...all]/
â”œâ”€â”€ og/               # OGP image generation
â””â”€â”€ webhooks/         # Webhook reception
    â””â”€â”€ stripe/
```

### Integrating Hono into Next.js

The main API is implemented with Hono. The API implementation lives in `server/api/`, while `app/api/` only contains minimal code for connecting to Next.js.

**Benefits of using Hono:**

- **Flexible directory structure**: Next.js Route Handlers require files under `app/api/`, but with Hono you can organize freely in `server/api/`
- **Auto-generated OpenAPI specs**: Using `@hono/zod-openapi`, you can auto-generate API documentation (openapi.json)
- **Framework agnostic**: If you migrate away from Next.js in the future, the API part can be reused

```tsx
// app/api/[[...route]]/route.ts
// Only the connection to Next.js
import { handle } from 'hono/vercel';
import { app } from '@/server/api';

export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const DELETE = handle(app);
```

### Separating Auth API

Better Auth is handled at a dedicated endpoint.

```tsx
// app/api/auth/[...all]/route.ts
import { toNextJsHandler } from 'better-auth/next-js';
import { auth } from '@/server/lib/auth/better-auth';

const handler = toNextJsHandler(auth);

export async function GET(request: NextRequest) {
  return await handler.GET(request);
}
```

`/api/auth/*` is handled by Better Auth, everything else by Hono.

## ğŸ–¥ï¸ Designing for Server Components

The biggest advantage of App Router is Server Components. To maximize this benefit, I keep layouts as Server Components.

### Before: Layout as Client Component

```tsx
// âŒ If layout.tsx has "use client", all pages become CSR
"use client";

export default function MainLayout({ children }) {
  const [state, setState] = useState();
  return <div>{children}</div>;
}
```

### After: Keep Layout as Server Component

Keep `layout.tsx` itself as a Server Component, and extract only the parts needing state management as Client Components.

```tsx
// âœ… Keep layout.tsx as Server Component
export default function MainLayout({ children }) {
  return (
    <div className="flex">
      <Sidebar />
      <ClientProvider>  {/* Only state management as Client Component */}
        {children}
      </ClientProvider>
    </div>
  );
}
```

```tsx
// ClientProvider.tsx
"use client";

export function ClientProvider({ children }) {
  const [state, setState] = useState();
  return <Context.Provider value={state}>{children}</Context.Provider>;
}
```

This way, child pages under `layout.tsx` can benefit from SSR and Streaming.

## ğŸ”€ Bonus: Parallel Routes and Intercepting Routes

For more advanced routing, there are Parallel Routes and Intercepting Routes. In Memoreru, I use these for table content row editing.

### Structure

```
contents/table/[id]/
â”œâ”€â”€ page.tsx           # Table detail page
â”œâ”€â”€ layout.tsx         # Parallel Routes definition
â”œâ”€â”€ @roweditor/        # Row edit panel (Parallel Route)
â”‚   â”œâ”€â”€ default.tsx    # Default (show nothing)
â”‚   â””â”€â”€ (.)rows/       # Intercepting Route
â”‚       â””â”€â”€ [rowId]/
â”‚           â””â”€â”€ page.tsx
â””â”€â”€ rows/              # Regular row edit page
    â””â”€â”€ [rowId]/
        â””â”€â”€ page.tsx
```

### How Parallel Routes Work

`layout.tsx` receives multiple slots.

```tsx
export default function TableContentLayout({
  children,
  roweditor,
}: {
  children: ReactNode;
  roweditor: ReactNode;
}) {
  return (
    <>
      {children}   {/* Table detail */}
      {roweditor}  {/* Row edit panel */}
    </>
  );
}
```

### Effect of Intercepting Routes

`(.)rows/[rowId]/` detects link clicks within the table detail page and switches to a different display method.

- **Direct access** `/contents/table/123/rows/456` â†’ Dedicated row edit page
- **Navigation from table** â†’ Slide-in panel display

Users experience different UIs for the same URL depending on how they accessed it.

```tsx
// Slide-in panel implementation
export default function RowEditorSlideIn({ params }) {
  const router = useRouter();
  const { id, rowId } = use(params);

  const handleClose = () => {
    router.back(); // Go back in history to close panel
  };

  return <TableRowEditPanel tableId={id} rowIndex={rowId} onClose={handleClose} />;
}
```

## âœ… Summary

Here are the key points for App Router directory design.

**Key Points:**
- app/ for routing definitions only, no logic
- Separate concerns with client/, server/, shared/
- Separate layouts with Route Groups
- Keep layouts as Server Components

There's no single right answer for directory design, but establishing consistent rules makes code location predictable.

Tomorrow I'll explain "Why I Migrated from MPA to SPA."

---

**Other Articles in This Series**

- Day 9: NextAuth.js to Better Auth: Why I Switched Auth Libraries
- Day 11: Why I Migrated from MPA to SPA: App Router Refactoring in Practice
